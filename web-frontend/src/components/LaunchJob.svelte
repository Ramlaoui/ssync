<script lang="ts">
  import { onDestroy } from "svelte";
  import { api } from "../services/api";
  import type { AxiosError } from "axios";
  import { onMount, tick } from "svelte";
  import { get } from "svelte/store";
  import type { LaunchJobRequest, LaunchJobResponse, HostInfo } from "../types/api";
  // Import new components
  import FileBrowser from "./FileBrowser.svelte";
  import JobConfigForm from "./JobConfigForm.svelte";
  import ScriptPreview from "./ScriptPreview.svelte";
  import SyncSettings from "./SyncSettings.svelte";
  import ConfirmationDialog from "./ConfirmationDialog.svelte";
  import ScriptHistory from "./ScriptHistory.svelte";
  import JobEditor from "./JobEditor.svelte";
  import JobLauncher from "./JobLauncher.svelte";
  // Import store and actions
  import {
    config,
    error,
    generatedScript,
    hosts as hostsStore,
    isValid,
    jobLaunchActions,
    launching,
    loading,
    success,
    validationDetails,
  } from "../stores/jobLaunch";
  // Import jobParameters store for sync functionality
  import { 
    jobParameters, 
    hasParameterConflicts,
    parametersValid
  } from "../stores/jobParameters";
  // Import resubmit store
  import { resubmitStore } from "../stores/resubmit";

  // Accept hosts as prop
  export let hosts: HostInfo[] = [];

  // Confirmation dialog state
  let showConfirmationDialog = false;
  let confirmationMessage = "";
  let directoryStats: { file_count: number; size_mb: number; dangerous_path: boolean; gitignore_applied?: boolean } | null = null;
  let pendingLaunchRequest: LaunchJobRequest | null = null;

  // Simplified state management
  
  // Resubmit info
  let resubmitInfo: { originalJobId: string; hasSubmitLine?: boolean } | null = null;
  
  // Script history dialog
  let showScriptHistory = false;

  // Mobile detection
  let isMobile = typeof window !== 'undefined' && window.innerWidth < 768;
  
  function handleScriptHistorySelect(event: CustomEvent) {
    const { script, jobName, hostname } = event.detail;
    // Update the script in the store
    jobParameters.setResubmitScript(script);
    // Optionally set job name and host
    if (jobName) {
      jobParameters.updateParameter('jobName', jobName + '_copy');
    }
    if (hostname && $config.selectedHost !== hostname) {
      jobLaunchActions.setSelectedHost(hostname);
    }
    showScriptHistory = false;
  }


  onMount(async () => {
    // Check for resubmit data first
    const resubmitData = resubmitStore.consumeResubmitData();
    console.log('LaunchJob mounted, resubmit data:', resubmitData);
    
    // Use hosts prop if available, otherwise load them
    if (hosts && hosts.length > 0) {
      jobLaunchActions.setHosts(hosts);
      
      // Handle resubmit data if present
      if (resubmitData) {
        resubmitInfo = { 
          originalJobId: resubmitData.originalJobId,
          hasSubmitLine: !!resubmitData.submitLine
        };
        
        // Clean the resubmit script to remove any auto-generated headers
        let cleanedScript = resubmitData.scriptContent;
        
        // Remove the auto-generated header if present
        cleanedScript = cleanedScript.replace(/^#!/, '{{SHEBANG}}'); // Temporarily mark shebang
        cleanedScript = cleanedScript.replace(/^# Generated by ssync\n# Host:.*\n# Source:.*\n\n?/m, '');
        cleanedScript = cleanedScript.replace(/^# Main job script \(runs on compute node\)\n\n?/m, '');
        cleanedScript = cleanedScript.replace(/\{\{SHEBANG\}\}/, '#!/'); // Restore shebang
        
        // Enable resubmit mode to prevent form from overriding script
        jobParameters.setResubmitMode(true);
        
        // Use the new resubmit-specific method
        jobParameters.setResubmitScript(cleanedScript);
        
        // Set the selected host (without applying defaults)
        jobLaunchActions.setSelectedHost(resubmitData.hostname);
        
        // Set the directory
        if (resubmitData.workDir) {
          jobLaunchActions.setSourceDir(resubmitData.workDir);
        }
        
        // Update job name with a suffix (this overrides what was parsed from script)
        if (resubmitData.jobName) {
          const timestamp = new Date().toISOString().slice(11, 19).replace(/:/g, '-');
          jobParameters.setParameterValue('job_name', `${resubmitData.jobName}_rerun_${timestamp}`);
        }
        
        // Script is now always visible in unified interface
      } else if (!$config.selectedHost) {
        // Auto-select first host if none selected
        jobLaunchActions.setSelectedHost(hosts[0].hostname);
        jobLaunchActions.applyHostDefaults(hosts[0].hostname);
        // Also apply to jobParameters store
        const selectedHost = hosts.find(h => h.hostname === hosts[0].hostname);
        if (selectedHost) {
          jobParameters.applyHostDefaults(selectedHost);
        }
      }
    } else {
      await loadHosts();
      
      // Handle resubmit data after hosts are loaded
      if (resubmitData) {
        resubmitInfo = { 
          originalJobId: resubmitData.originalJobId,
          hasSubmitLine: !!resubmitData.submitLine
        };
        
        // Clean the resubmit script to remove any auto-generated headers
        let cleanedScript = resubmitData.scriptContent;
        
        // Remove the auto-generated header if present
        cleanedScript = cleanedScript.replace(/^#!/, '{{SHEBANG}}'); // Temporarily mark shebang
        cleanedScript = cleanedScript.replace(/^# Generated by ssync\n# Host:.*\n# Source:.*\n\n?/m, '');
        cleanedScript = cleanedScript.replace(/^# Main job script \(runs on compute node\)\n\n?/m, '');
        cleanedScript = cleanedScript.replace(/\{\{SHEBANG\}\}/, '#!/'); // Restore shebang
        
        // Enable resubmit mode to prevent form from overriding script
        jobParameters.setResubmitMode(true);
        
        // Use the new resubmit-specific method
        jobParameters.setResubmitScript(cleanedScript);
        
        // Set the selected host (without applying defaults)
        jobLaunchActions.setSelectedHost(resubmitData.hostname);
        
        // Set the directory
        if (resubmitData.workDir) {
          jobLaunchActions.setSourceDir(resubmitData.workDir);
        }
        
        // Update job name with a suffix (this overrides what was parsed from script)
        if (resubmitData.jobName) {
          const timestamp = new Date().toISOString().slice(11, 19).replace(/:/g, '-');
          jobParameters.setParameterValue('job_name', `${resubmitData.jobName}_rerun_${timestamp}`);
        }
        
        // Script is now always visible in unified interface
      }
    }
    
    // Only initialize with the generated script template if not resubmitting
    if (!resubmitData) {
      jobParameters.setScriptContent($generatedScript);
    }
  });

  // Only use generated script when sync is off and there's no existing script content
  // This prevents overwriting user edits
  let scriptInitialized = false;
  $: if (!scriptInitialized && $jobParameters.syncMode === 'off' && !$jobParameters.scriptContent) {
    jobParameters.setScriptContent($generatedScript, true);
    scriptInitialized = true;
  }
  
  // debug: trace $launching changes

  async function loadHosts(): Promise<void> {
    jobLaunchActions.setLoading(true);
    try {
      const response = await api.get('/api/hosts');
      jobLaunchActions.setHosts(response.data);

      // Auto-select first host if none selected
      if (response.data.length > 0 && !$config.selectedHost) {
        jobLaunchActions.setSelectedHost(response.data[0].hostname);
        jobLaunchActions.applyHostDefaults(response.data[0].hostname);
      }
    } catch (err: unknown) {
      const axiosError = err as AxiosError;
      jobLaunchActions.setError(`Failed to load hosts: ${axiosError.message}`);
    } finally {
      jobLaunchActions.setLoading(false);
    }
  }

  // Add flag to prevent duplicate submissions
  let isCurrentlyLaunching = false;
  
  async function launchJob(forceSync: boolean = false): Promise<void> {
    // Prevent duplicate submissions
    if (isCurrentlyLaunching) {
      console.warn('Job launch already in progress, ignoring duplicate request');
      return;
    }
    
    // Validate using store
    if (!$isValid) {
      jobLaunchActions.setError("Please complete all required fields");
      return;
    }

    isCurrentlyLaunching = true;
    jobLaunchActions.setLaunching(true);
    jobLaunchActions.resetMessages();

    try {
      const cfg = $config;
      // Use the script from jobParameters store which has the correctly parsed/synced content
      // Fall back to config.scriptContent only if jobParameters doesn't have content
      const scriptContent = $jobParameters.scriptContent || cfg.scriptContent;
      const scriptToSend =
        cfg.scriptSource === "local"
          ? `{{LOCAL:${cfg.localScriptPath}}}`
          : scriptContent;

      const request: LaunchJobRequest = {
        script_content: scriptToSend,
        source_dir: cfg.sourceDir,
        host: cfg.selectedHost,
        job_name: cfg.jobName || undefined,
        cpus: cfg.cpus || undefined,
        mem: cfg.useMemory ? cfg.memory : undefined,
        time: cfg.timeLimit || undefined,
        partition: cfg.partition || undefined,
        ntasks_per_node: cfg.ntasksPerNode || undefined,
        n_tasks_per_node: cfg.ntasksPerNode || undefined,
        nodes: cfg.nodes || undefined,
        gpus_per_node: cfg.gpusPerNode || undefined,
        gres: cfg.gres || undefined,
        output: cfg.outputFile || undefined,
        error: cfg.errorFile || undefined,
        constraint: cfg.constraint || undefined,
        account: cfg.account || undefined,
        exclude: cfg.excludePatterns,
        include: cfg.includePatterns,
        no_gitignore: cfg.noGitignore,
        force_sync: forceSync,
      };

      const response = await api.post<LaunchJobResponse>(
        '/api/jobs/launch',
        request,
      );

      if (response.data.success) {
        jobLaunchActions.setSuccess(
          `Job launched successfully! Job ID: ${response.data.job_id}`,
        );
        
        // Show directory warning if present
        if (response.data.directory_warning) {
          jobLaunchActions.setError(`Warning: ${response.data.directory_warning}`);
        }
        
        // Reset some fields but keep host and directory
        jobLaunchActions.updateJobConfig({
          jobName: "",
          outputFile: "",
          errorFile: "",
          gres: "",
          scriptContent:
            '#!/bin/bash\n\n# Your script here\necho "Hello, SLURM!"',
          scriptSource: "editor",
          localScriptPath: "",
          uploadedScriptName: "",
          useMemory: false,
        });
      } else {
        // Check if this requires confirmation
        if (response.data.requires_confirmation) {
          // Store the request for retry with force_sync
          pendingLaunchRequest = request;
          confirmationMessage = response.data.message;
          directoryStats = response.data.directory_stats || null;
          showConfirmationDialog = true;
          jobLaunchActions.setLaunching(false);
          isCurrentlyLaunching = false; // Reset flag when showing confirmation
          return;
        }
        
        jobLaunchActions.setError(response.data.message);
      }
    } catch (err: unknown) {
      const axiosError = err as AxiosError<{ detail?: string; message?: string }>;
      
      // Extract error message with better formatting
      let errorMessage = "Failed to launch job";
      
      if (axiosError.response) {
        // Server responded with error
        const status = axiosError.response.status;
        const data = axiosError.response.data;
        
        if (data?.detail) {
          errorMessage = data.detail;
        } else if (data?.message) {
          errorMessage = data.message;
        } else if (status === 400) {
          errorMessage = "Invalid request: Please check your configuration";
        } else if (status === 401) {
          errorMessage = "Authentication failed: Please check your API key";
        } else if (status === 403) {
          errorMessage = "Permission denied: You don't have access to this resource";
        } else if (status === 404) {
          errorMessage = "Resource not found: The specified host or path doesn't exist";
        } else if (status === 500) {
          errorMessage = "Server error: Something went wrong on the server";
        } else if (status === 503) {
          errorMessage = "Service unavailable: The server is temporarily unavailable";
        } else {
          errorMessage = `Server error (${status}): ${axiosError.message}`;
        }
      } else if (axiosError.request) {
        // Request was made but no response
        errorMessage = "Network error: Could not connect to the server. Please check your connection.";
      } else {
        // Error in request setup
        errorMessage = `Configuration error: ${axiosError.message}`;
      }
      
      jobLaunchActions.setError(errorMessage);
    } finally {
      jobLaunchActions.setLaunching(false);
      isCurrentlyLaunching = false;
    }
  }

  // Event handlers for component communication
  function handleConfigChange(event: CustomEvent) {
    jobLaunchActions.updateJobConfig(event.detail);
  }

  function handleScriptChange(event: CustomEvent) {
    // Handle script changes with jobParameters sync
    const raw = event.detail.content as string;
    
    // Update jobParameters store for real-time sync
    jobParameters.handleScriptEdit(raw);
    
    // Store the full script content including #SBATCH directives
    jobLaunchActions.setScriptContent(raw);
  }

  function handleSyncSettingsChange(event: CustomEvent) {
    jobLaunchActions.setSyncSettings(event.detail);
  }

  function handleConfigFromEditor(event: CustomEvent) {
    // Handle configuration changes from the integrated editor
    const config = event.detail;
    
    // Update jobParameters store with the new configuration
    if (config.jobName) {
      jobParameters.updateParameter('jobName', config.jobName);
    }
    if (config.partition) {
      jobParameters.updateParameter('partition', config.partition);
    }
    if (config.timeLimit) {
      jobParameters.updateParameter('timeLimit', config.timeLimit);
    }
    if (config.memory) {
      jobParameters.updateParameter('memory', config.memory);
    }
    if (config.cpus) {
      jobParameters.updateParameter('cpus', config.cpus);
    }
    if (config.nodes) {
      jobParameters.updateParameter('nodes', config.nodes);
    }
    if (config.gpusPerNode !== undefined) {
      jobParameters.updateParameter('gpusPerNode', config.gpusPerNode);
    }
  }

  function handlePathSelected(event: CustomEvent) {
    jobLaunchActions.setSourceDir(event.detail);
  }

  function handleLaunchJob() {
    launchJob();
  }

  function handleConfirmForceSync() {
    showConfirmationDialog = false;
    if (pendingLaunchRequest) {
      launchJob(true); // Retry with force_sync = true
      pendingLaunchRequest = null;
      directoryStats = null;
    }
  }

  function handleCancelForceSync() {
    showConfirmationDialog = false;
    pendingLaunchRequest = null;
    directoryStats = null;
    jobLaunchActions.setLaunching(false);
  }
  
  // Handlers for parameter sync
  function handleSyncModeChange(event: CustomEvent) {
    jobParameters.setSyncMode(event.detail.mode);
  }

  function handleHostChange(event: Event) {
    const target = event.target as HTMLSelectElement;
    const hostname = target.value;
    
    // Update the selected host
    const detail = { selectedHost: hostname };
    
    // Use the same handler as the form to ensure consistency
    handleConfigChangeWithSync({ detail } as CustomEvent);
    
    // Apply host defaults if available
    if (hostname) {
      const selectedHost = $hostsStore.find((h: HostInfo) => h.hostname === hostname);
      if (selectedHost && selectedHost.slurm_defaults) {
        const defaults = selectedHost.slurm_defaults;
        const updates: any = {};
        
        // Apply all the defaults just like JobConfigForm does
        if (defaults.partition) updates.partition = defaults.partition;
        if (defaults.account) updates.account = defaults.account;
        if (defaults.constraint) updates.constraint = defaults.constraint;
        if (defaults.cpus) updates.cpus = defaults.cpus;
        if (defaults.time) {
          const timeParts = defaults.time.split(':');
          const hours = parseInt(timeParts[0], 10) || 0;
          const minutes = parseInt(timeParts[1], 10) || 0;
          updates.timeLimit = hours * 60 + minutes;
        }
        if (defaults.mem) {
          updates.memory = defaults.mem;
          updates.useMemory = true;
        }
        if (defaults.nodes) updates.nodes = defaults.nodes;
        if (defaults.gpus_per_node) updates.gpusPerNode = defaults.gpus_per_node;
        
        // Apply all updates through the sync handler
        handleConfigChangeWithSync({ detail: updates } as CustomEvent);
      }
    }
  }
  
  function handleConflictResolution(event: CustomEvent) {
    jobParameters.setConflictResolution(event.detail.strategy);
  }
  
  // Sync config changes to jobParameters
  function handleConfigChangeWithSync(event: CustomEvent) {
    const detail = event.detail;
    jobLaunchActions.updateJobConfig(detail);
    
    // Skip syncing to jobParameters if we're in resubmit mode
    // The script is the source of truth during resubmit
    if ($jobParameters.isResubmit) {
      return;
    }
    
    // Always sync form changes to jobParameters (bidirectional)
    // Sync specific parameters to jobParameters store
    if ('cpus' in detail) jobParameters.updateParameter('cpus', detail.cpus, !!detail.cpus);
    if ('memory' in detail) jobParameters.updateParameter('mem', detail.memory, detail.useMemory);
    if ('timeLimit' in detail) jobParameters.updateParameter('time', detail.timeLimit, !!detail.timeLimit);
    if ('partition' in detail) jobParameters.updateParameter('partition', detail.partition, !!detail.partition);
    if ('jobName' in detail) jobParameters.updateParameter('job_name', detail.jobName, !!detail.jobName);
    if ('nodes' in detail) jobParameters.updateParameter('nodes', detail.nodes, !!detail.nodes);
    if ('gpusPerNode' in detail) jobParameters.updateParameter('gpus_per_node', detail.gpusPerNode, !!detail.gpusPerNode);
    if ('ntasksPerNode' in detail) jobParameters.updateParameter('ntasks_per_node', detail.ntasksPerNode, !!detail.ntasksPerNode);
    if ('account' in detail) jobParameters.updateParameter('account', detail.account, !!detail.account);
    if ('constraint' in detail) jobParameters.updateParameter('constraint', detail.constraint, !!detail.constraint);
    if ('gres' in detail) jobParameters.updateParameter('gres', detail.gres, !!detail.gres);
    if ('outputFile' in detail) jobParameters.updateParameter('output', detail.outputFile, !!detail.outputFile);
    if ('errorFile' in detail) jobParameters.updateParameter('error', detail.errorFile, !!detail.errorFile);
  }
</script>

<div class="launch-page-wrapper">
<div class="launch-container-modern">
  <div class="launch-notifications">
    {#if $error}
      <div class="error-message" role="alert">
      <div class="error-icon">
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z"
          />
        </svg>
      </div>
      <div class="error-content">
        <strong>Error:</strong> {$error}
      </div>
      <button 
        class="error-dismiss" 
        on:click={() => jobLaunchActions.setError(null)}
        aria-label="Dismiss error"
      >
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z" />
        </svg>
      </button>
    </div>
  {/if}

  {#if $success}
    <div class="success-message">
      <svg viewBox="0 0 24 24" fill="currentColor">
        <path
          d="M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M17,9L12,14L7,9L8.41,7.59L12,11.17L15.59,7.59L17,9Z"
        />
      </svg>
      {$success}
    </div>
  {/if}
  
  {#if resubmitInfo}
    <div class="info-banner">
      <svg viewBox="0 0 24 24" fill="currentColor">
        <path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z"/>
      </svg>
      <span>
        Loaded script from Job {resubmitInfo.originalJobId}
        {resubmitInfo.hasSubmitLine ? ' with runtime parameters included' : ''}.
        You can modify it before resubmitting.
      </span>
      <button class="close-banner" on:click={() => resubmitInfo = null}>
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z"/>
        </svg>
      </button>
    </div>
  {/if}
  </div>

  <!-- Modern Unified Interface -->
  <div class="launch-content">
    <JobLauncher
    script={$jobParameters.scriptContent || $generatedScript}
    launching={$launching}
    hosts={$hostsStore}
    selectedHost={$config.selectedHost}
    loading={$loading}
    validationDetails={$validationDetails}
    config={$config}
    on:launch={handleLaunchJob}
    on:scriptChanged={handleScriptChange}
    on:configChanged={handleConfigFromEditor}
    on:pathSelected={handlePathSelected}
    on:syncSettingsChanged={handleSyncSettingsChange}
    on:openHistory={() => showScriptHistory = true}
  />
  </div>
</div>
</div>

<!-- Script History Sidebar -->
<ScriptHistory
  bind:isOpen={showScriptHistory}
  currentHost={$config.selectedHost}
  {isMobile}
  on:select={handleScriptHistorySelect}
  on:close={() => showScriptHistory = false}
/>

<!-- Large Directory Confirmation Dialog -->
<ConfirmationDialog
  bind:show={showConfirmationDialog}
  title="Large Directory Detected"
  message={confirmationMessage}
  confirmText="Force Sync"
  cancelText="Cancel"
  confirmButtonClass="primary"
  stats={directoryStats}
  on:confirm={handleConfirmForceSync}
  on:cancel={handleCancelForceSync}
/>

<style>
  .launch-page-wrapper {
    height: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  .launch-container-modern {
    width: 100%;
    flex: 1;
    display: flex;
    flex-direction: column;
    background: #f8fafc;
    overflow: hidden; /* Prevent scrollbars on the container */
    position: relative;
    min-height: 0;
  }

  .launch-notifications {
    flex-shrink: 0; /* Don't allow notifications to shrink */
  }

  .launch-content {
    flex: 1;
    min-height: 0; /* Allow content to shrink */
    overflow: hidden;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  .error-message,
  .success-message {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 1rem 1.25rem;
    border-radius: 10px;
    margin: 0; /* Remove margins that add to height */
    flex-shrink: 0; /* Don't shrink these messages */
    font-size: 0.9rem;
    font-weight: 500;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(10px);
    position: relative;
  }

  .error-message {
    background: linear-gradient(135deg, #fef2f2 0%, #fde8e8 100%);
    color: #dc2626;
    border: 1px solid #fecaca;
    padding-right: 3rem;
  }
  
  .error-icon {
    display: flex;
    align-items: center;
    flex-shrink: 0;
  }
  
  .error-content {
    flex: 1;
    line-height: 1.5;
  }
  
  .error-content strong {
    font-weight: 600;
    margin-right: 0.5rem;
  }
  
  .error-dismiss {
    position: absolute;
    right: 0.5rem;
    top: 50%;
    transform: translateY(-50%);
    background: transparent;
    border: none;
    cursor: pointer;
    padding: 0.25rem;
    border-radius: 4px;
    transition: background 0.2s ease;
    color: #dc2626;
  }
  
  .error-dismiss:hover {
    background: rgba(220, 38, 38, 0.1);
  }
  
  .error-dismiss svg {
    width: 1.2rem;
    height: 1.2rem;
  }

  .success-message {
    background: linear-gradient(135deg, #f0fdf4 0%, #e8f5e8 100%);
    color: #16a34a;
    border: 1px solid #bbf7d0;
  }

  .error-icon svg,
  .success-message svg {
    width: 1.2rem;
    height: 1.2rem;
    flex-shrink: 0;
  }
  
  .info-banner {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 1rem 1.25rem;
    border-radius: 10px;
    margin: 1.5rem 1.5rem 0;
    font-size: 0.9rem;
    font-weight: 500;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(10px);
    background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
    color: #1e40af;
    border: 1px solid #bfdbfe;
    position: relative;
    padding-right: 3rem;
  }
  
  .info-banner svg {
    width: 1.2rem;
    height: 1.2rem;
    flex-shrink: 0;
  }
  
  .info-banner span {
    flex: 1;
  }
  
  .close-banner {
    position: absolute;
    right: 0.75rem;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: #1e40af;
    cursor: pointer;
    padding: 0.25rem;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0.7;
    transition: opacity 0.2s;
  }
  
  .close-banner:hover {
    opacity: 1;
  }
  
  .close-banner svg {
    width: 1rem;
    height: 1rem;
  }

  /* Unified Content Scrollbars */
  .content-panel::-webkit-scrollbar {
    width: 6px;
  }

  .content-panel::-webkit-scrollbar-track {
    background: transparent;
  }

  .content-panel::-webkit-scrollbar-thumb {
    background: rgba(156, 163, 175, 0.3);
    border-radius: 3px;
  }

  .content-panel::-webkit-scrollbar-thumb:hover {
    background: rgba(156, 163, 175, 0.5);
  }

  /* Mobile responsive */
  @media (max-width: 1200px) {
    .main-layout {
      flex-direction: column;
      gap: 1rem;
      height: calc(100vh - 3rem);
    }

    .content-panel {
      flex: 0 0 auto;
      max-height: 40vh;
      min-height: 300px;
    }

    .script-panel {
      flex: 1;
      min-height: 400px;
    }
  }

  /* Mobile Tab Navigation Styles */
  .mobile-tabs {
    display: flex;
    background: white;
    border-bottom: 1px solid #e1e5e9;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    position: sticky;
    top: 0;
    z-index: 100;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }

  .tab-button {
    flex: 1;
    min-width: 80px;
    padding: 0.75rem 0.5rem;
    background: none;
    border: none;
    border-bottom: 3px solid transparent;
    color: #6b7280;
    font-size: 0.75rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.25rem;
    white-space: nowrap;
  }

  .tab-button svg {
    width: 20px;
    height: 20px;
  }

  .tab-button:hover {
    background: #f9fafb;
  }

  .tab-button.active {
    color: #6366f1;
    border-bottom-color: #6366f1;
    background: #eef2ff;
  }

  /* Minimal Integrated Toolbar Styles */
  .left-toolbar {
    width: 48px;
    background: transparent;
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 10;
    padding: 0.75rem 0;
  }


  .toolbar-nav {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    width: 100%;
    align-items: center;
  }

  .toolbar-button {
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    border: none;
    border-radius: 8px;
    color: var(--color-text-secondary, #6c757d);
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
  }

  .toolbar-button svg {
    width: 18px;
    height: 18px;
    transition: all 0.2s ease;
  }

  .toolbar-button:hover {
    background: var(--color-accent-alpha, rgba(52, 152, 219, 0.1));
    color: var(--color-text-primary, #212529);
    transform: scale(1.05);
  }

  .toolbar-button:hover svg {
    transform: scale(1.1);
  }

  .toolbar-button.active {
    background: var(--color-accent, #3498db);
    color: white;
    box-shadow: 0 2px 6px rgba(52, 152, 219, 0.25);
  }

  .toolbar-button.active svg {
    transform: scale(1.1);
  }

  /* Compact Tooltip Styles */
  .toolbar-tooltip {
    position: absolute;
    left: 42px;
    top: 50%;
    transform: translateY(-50%);
    background: var(--color-text-primary, #212529);
    color: white;
    padding: 0.375rem 0.5rem;
    border-radius: 6px;
    font-size: 0.75rem;
    font-weight: 500;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: all 0.2s ease;
    z-index: 1000;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  }

  .toolbar-tooltip::before {
    content: '';
    position: absolute;
    right: 100%;
    top: 50%;
    transform: translateY(-50%);
    border: 4px solid transparent;
    border-right-color: var(--color-text-primary, #212529);
  }

  .toolbar-button:hover .toolbar-tooltip {
    opacity: 1;
    visibility: visible;
    left: 46px;
  }

  .toolbar-spacer {
    flex: 1;
  }

  .toolbar-footer {
    margin-top: auto;
    padding-top: 0.5rem;
    width: 100%;
    display: flex;
    justify-content: center;
    opacity: 0.3;
    /* Reserved for future tools */
  }

  /* Streamlined Content Area */
  .content-area {
    flex: 1;
    display: flex;
    gap: 1.5rem;
    min-height: 0;
    padding: 1.5rem;
    background: var(--body-bg, #f9fafb);
    overflow: hidden;
  }

  .content-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
    min-height: 0;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 1.5rem;
    -webkit-overflow-scrolling: touch;
    background: white;
    border-radius: 12px;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
  }
  
  .content-panel.full-width {
    max-width: 100%;
  }

  .script-panel {
    flex: 1.2;
    display: flex;
    flex-direction: column;
    min-width: 0;
    min-height: 0;
    background: white;
    border-radius: 12px;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
    overflow: hidden;
  }


  .mobile-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    min-height: 0;
  }

  .mobile-tab-content {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    -webkit-overflow-scrolling: touch;
    padding: 1rem;
  }

  .mobile-tab-content.script-tab {
    padding: 0;
    display: flex;
    flex-direction: column;
  }

  /* Mobile quick host selector in script view */
  .mobile-quick-host-selector {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    border-bottom: 1px solid #e2e8f0;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
  }

  .mobile-quick-host-selector label {
    font-size: 0.875rem;
    font-weight: 600;
    color: #475569;
    white-space: nowrap;
  }

  .mobile-host-select {
    flex: 1;
    padding: 0.5rem 0.75rem;
    font-size: 0.875rem;
    background: white;
    border: 1px solid #cbd5e1;
    border-radius: 8px;
    color: #1e293b;
    font-weight: 500;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23475569' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 0.75rem center;
    padding-right: 2.5rem;
    transition: all 0.2s ease;
  }

  .mobile-host-select:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  .mobile-host-select:disabled {
    opacity: 0.6;
    background-color: #f8fafc;
  }

  .browser-section.mobile,
  .sync-settings-wrapper.mobile {
    background: white;
    border-radius: 12px;
    padding: 1rem;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
  }

  .browser-section.mobile h3 {
    margin: 0 0 1rem 0;
    font-size: 1.1rem;
    color: #374151;
  }

  /* Mobile Layout */
  @media (max-width: 768px) {
    .launch-container {
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: #f8fafc;
    }
    
    .content-controls {
      padding: 0.75rem 1rem;
    }
    
    .view-selection {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .view-tab {
      padding: 0.5rem 0.75rem;
      font-size: 0.8rem;
      flex-shrink: 0;
      min-width: 70px;
      justify-content: center;
      gap: 0.25rem;
    }
    
    .view-tab svg {
      width: 14px;
      height: 14px;
    }
    
    .tab-label {
      display: none;
    }
    
    .tab-content {
      padding: 0.75rem;
    }

    .error-message,
    .success-message {
      margin: 0.5rem;
      padding: 0.75rem;
      font-size: 0.85rem;
      border-radius: 8px;
    }

    .error-message svg,
    .success-message svg {
      width: 1rem;
      height: 1rem;
    }
  }

  /* Small Mobile Adjustments */
  @media (max-width: 480px) {
    .view-tab {
      font-size: 0.7rem;
      padding: 0.5rem 0.5rem;
      min-width: 60px;
    }

    .view-tab svg {
      width: 12px;
      height: 12px;
    }

    .tab-content {
      padding: 0.5rem;
    }

    .mobile-quick-host-selector {
      padding: 0.5rem 0.75rem;
      gap: 0.5rem;
    }

    .mobile-quick-host-selector label {
      font-size: 0.8rem;
    }

    .mobile-host-select {
      padding: 0.4rem 0.6rem;
      font-size: 0.8rem;
      padding-right: 2rem;
    }

    .browser-section.mobile,
    .sync-settings-wrapper.mobile {
      padding: 0.875rem;
    }
  }
</style>
