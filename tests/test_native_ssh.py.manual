#!/usr/bin/env python3
"""Test script for native SSH backend."""

import asyncio
import os
import sys
from pathlib import Path

# Add src directory to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

from ssync.connection import ConnectionManager
from ssync.models.cluster import Host
from ssync.ssh import ConnectionPurpose, get_ssh_backend
from ssync.utils.logging import setup_logger

logger = setup_logger(__name__)


async def test_native_ssh():
    """Test native SSH backend functionality."""

    # Test with different backend settings
    test_configs = [
        ("fabric", "Testing with Fabric backend"),
        ("native", "Testing with Native SSH backend"),
        ("auto", "Testing with Auto backend selection"),
    ]

    # Create a test host (modify this to match your actual host)
    test_host = Host(
        hostname="localhost",  # Change to your test host
        username=os.environ.get("USER"),
        port=22,
    )

    for backend_name, description in test_configs:
        print(f"\n{'=' * 60}")
        print(f"{description}")
        print(f"{'=' * 60}")

        # Set backend
        os.environ["SSYNC_SSH_BACKEND"] = backend_name

        # Create new connection manager
        conn_manager = ConnectionManager()
        backend = get_ssh_backend()
        print(f"Active backend: {backend.value}")

        # Test different connection purposes
        purposes = [
            (None, "Main connection"),
            (ConnectionPurpose.MAIN, "Main purpose connection"),
            (ConnectionPurpose.WATCHER, "Watcher purpose connection"),
            (ConnectionPurpose.DOWNLOAD, "Download purpose connection"),
        ]

        for purpose, desc in purposes:
            print(f"\nTesting {desc}...")
            try:
                # Get connection
                conn = conn_manager.get_connection(test_host, purpose=purpose)

                # Run a simple command
                result = conn.run("echo 'Hello from SSH'", hide=True)

                if hasattr(result, "ok"):
                    if result.ok:
                        print(f"  ✓ Command successful: {result.stdout.strip()}")
                    else:
                        print(f"  ✗ Command failed: {result.stderr}")
                else:
                    print(f"  ? Result: {result}")

            except Exception as e:
                print(f"  ✗ Error: {e}")

        # Test concurrent connections (important for watcher non-blocking)
        if backend_name in ["native", "auto"]:
            print("\nTesting concurrent connections...")

            async def run_command(purpose, command, delay=0):
                """Run a command with optional delay."""
                if delay:
                    await asyncio.sleep(delay)

                conn = conn_manager.get_connection(test_host, purpose=purpose)

                # For native connections, we need to handle async properly
                if hasattr(conn, "native") and hasattr(conn.native, "run_command"):
                    result = await conn.native.run_command(command)
                    return result.stdout if result.success else result.stderr
                else:
                    # Fabric connection - run in thread
                    loop = asyncio.get_event_loop()
                    result = await loop.run_in_executor(
                        None, lambda: conn.run(command, hide=True)
                    )
                    return result.stdout if result.ok else result.stderr

            try:
                # Run multiple commands concurrently
                tasks = [
                    run_command(ConnectionPurpose.MAIN, "echo 'Main 1'"),
                    run_command(
                        ConnectionPurpose.WATCHER, "sleep 1 && echo 'Watcher 1'"
                    ),
                    run_command(
                        ConnectionPurpose.WATCHER, "sleep 0.5 && echo 'Watcher 2'"
                    ),
                    run_command(ConnectionPurpose.DOWNLOAD, "echo 'Download 1'"),
                ]

                results = await asyncio.gather(*tasks, return_exceptions=True)

                for i, result in enumerate(results):
                    if isinstance(result, Exception):
                        print(f"  Task {i + 1} failed: {result}")
                    else:
                        print(f"  Task {i + 1} result: {result.strip()}")

            except Exception as e:
                print(f"  Concurrent test failed: {e}")

        # Get connection stats
        stats = conn_manager.get_stats()
        print("\nConnection statistics:")
        print(f"  Backend: {stats['backend']}")
        print(f"  Fabric connections: {stats['fabric_connections']}")
        if stats["native_pools"]:
            print("  Native pools:")
            for host_str, pool_stats in stats["native_pools"].items():
                print(f"    {host_str}: {pool_stats}")

        # Clean up
        conn_manager.close_all()
        print("\nConnections closed.")


def main():
    """Main entry point."""
    print("Testing SSH backend implementations...")
    print(f"Current working directory: {os.getcwd()}")

    # Run async tests
    asyncio.run(test_native_ssh())

    print("\n" + "=" * 60)
    print("Testing complete!")
    print("=" * 60)

    # Recommendations
    print("\nRecommendations:")
    print("1. If all tests pass, you can enable native SSH globally:")
    print("   export SSYNC_SSH_BACKEND=native")
    print("\n2. For gradual migration, use auto mode:")
    print("   export SSYNC_SSH_BACKEND=auto")
    print("\n3. To use native SSH only for watchers:")
    print("   export SSYNC_NATIVE_SSH_WATCHERS=true")
    print("\n4. To rollback to Fabric only:")
    print("   export SSYNC_SSH_BACKEND=fabric  # or unset")


if __name__ == "__main__":
    main()
