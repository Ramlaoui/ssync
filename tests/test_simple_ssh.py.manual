#!/usr/bin/env python3
"""Test the simplified SSH implementation with proper ControlMaster usage."""

import asyncio
import os
import sys
import time
from pathlib import Path

# Add src directory to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

from ssync.connection import ConnectionManager
from ssync.models.cluster import Host
from ssync.utils.logging import setup_logger

logger = setup_logger(__name__)


async def test_controlmaster():
    """Test ControlMaster functionality."""

    print("\n" + "=" * 60)
    print("Testing Simplified ControlMaster Implementation")
    print("=" * 60)

    # Test host configuration
    test_hosts = [
        Host(hostname="localhost", username=os.environ.get("USER"), port=22),
        # Add your actual hosts here for testing
        # Host(hostname="jz", username="", port=22),  # SSH alias
    ]

    for host in test_hosts:
        print(f"\nTesting host: {host.hostname}")
        print("-" * 40)

        # Create connection manager with native backend
        os.environ["SSYNC_SSH_BACKEND"] = "native"
        conn_manager = ConnectionManager()

        try:
            # Get multiple connections - they should all share the same ControlMaster
            print("Getting connections for different purposes...")

            conn1 = conn_manager.get_connection(host, purpose=None)
            print(f"  Connection 1 (Main): {type(conn1).__name__}")

            conn2 = conn_manager.get_connection(host, purpose="watcher")
            print(f"  Connection 2 (Watcher): {type(conn2).__name__}")

            # They should be the SAME object (one connection per host)
            if conn1 is conn2:
                print("  ✓ Same connection object (correct!)")
            else:
                print("  ✗ Different objects (should be same!)")

            # Run parallel commands through the same ControlMaster
            print("\nRunning parallel commands...")
            start = time.time()

            # These should run in parallel through the same socket
            result1 = conn1.run("echo 'Command 1' && sleep 1", timeout=5)
            result2 = conn2.run("echo 'Command 2' && sleep 1", timeout=5)
            result3 = conn1.run("echo 'Command 3' && sleep 1", timeout=5)

            elapsed = time.time() - start

            print(
                f"  Result 1: {result1.stdout.strip() if result1.ok else result1.stderr}"
            )
            print(
                f"  Result 2: {result2.stdout.strip() if result2.ok else result2.stderr}"
            )
            print(
                f"  Result 3: {result3.stdout.strip() if result3.ok else result3.stderr}"
            )
            print(f"  Time taken: {elapsed:.2f}s")

            if elapsed < 2:  # Should be ~1s if parallel
                print("  ✓ Commands ran in parallel!")
            else:
                print("  ✗ Commands ran sequentially (took {elapsed:.2f}s)")

            # Check statistics
            stats = conn_manager.get_stats()
            print("\nConnection statistics:")
            print(f"  Backend: {stats['backend']}")
            print(f"  Native connections: {stats['native_connections']}")
            print(f"  Active ControlMasters: {stats['control_masters']}")

            # Check control socket
            control_sockets = (
                list(Path("/tmp/ssync_ssh").glob("control_*.sock"))
                if Path("/tmp/ssync_ssh").exists()
                else []
            )
            print(f"  Control sockets on disk: {len(control_sockets)}")
            for sock in control_sockets:
                print(f"    - {sock.name}")

        except Exception as e:
            print(f"  Error: {e}")

        finally:
            # Clean up
            conn_manager.close_all()

    print("\n" + "=" * 60)
    print("Test complete!")
    print("=" * 60)


async def test_stress():
    """Stress test with many parallel commands."""

    print("\n" + "=" * 60)
    print("Stress Testing Parallel Commands")
    print("=" * 60)

    # Use localhost for stress test
    host = Host(hostname="localhost", username=os.environ.get("USER"), port=22)

    os.environ["SSYNC_SSH_BACKEND"] = "native"
    conn_manager = ConnectionManager()

    try:
        conn = conn_manager.get_connection(host)

        # Run many commands in parallel
        num_commands = 20
        print(f"Running {num_commands} commands in parallel...")

        start = time.time()
        results = []

        for i in range(num_commands):
            result = conn.run(f"echo 'Command {i}'", timeout=5)
            results.append(result)

        elapsed = time.time() - start
        successful = sum(1 for r in results if r.ok)

        print(f"  Commands completed: {len(results)}")
        print(f"  Successful: {successful}")
        print(f"  Time taken: {elapsed:.2f}s")
        print(f"  Commands per second: {len(results) / elapsed:.1f}")

        # Check we still have just ONE ControlMaster
        stats = conn_manager.get_stats()
        print(f"  Active ControlMasters: {stats['control_masters']}")

        if stats["control_masters"] == 1:
            print("  ✓ Still using single ControlMaster!")
        else:
            print(f"  ✗ Multiple ControlMasters created: {stats['control_masters']}")

    except Exception as e:
        print(f"  Error: {e}")

    finally:
        conn_manager.close_all()


def main():
    """Main entry point."""
    print("Testing Simplified SSH with Proper ControlMaster Usage")
    print(f"Current working directory: {os.getcwd()}")

    # Run tests
    asyncio.run(test_controlmaster())

    # Uncomment for stress test
    # asyncio.run(test_stress())

    print("\nKey benefits of this implementation:")
    print("1. ONE ControlMaster per host (not per purpose)")
    print("2. Unlimited parallel commands through the same socket")
    print("3. No complex pooling logic needed")
    print("4. SSH handles all the multiplexing automatically")
    print("5. Much simpler and more efficient!")


if __name__ == "__main__":
    main()
